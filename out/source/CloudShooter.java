/* autogenerated by Processing revision 1276 on 2022-01-10 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class CloudShooter extends PApplet {

//importar libraria grafica
//declarar objetos
public Menu m;
boolean displayGame = false;
CloudsGen c1, c2, c3, c4, c5;
PlayerShipMenu pm;
public Player p1;
public ArrayList<Enemy> e1;
public int score, lives, center_x, center_y;
public float hits;

 public void setup() { //codigo apenas executado no inicio do programa
  surface.setTitle("CloudShooter by Catarina & Claudio"); //titulo da janela
  /* size commented out by preprocessor */; //fullscreen
  frameRate(60); //especificar framerate a usar
  Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); //https://forum.processing.org/one/topic/dynamic-screen-background-resize-need-guidance.html //dinamic window size begin (without borders) //ir buscar a dimensao da tela
  int screenWidth = screenSize.width; //ir buscar a largura da tela
  int screenHeight = screenSize.height; //ir buscar a largura da tela
  surface.setSize(1920, 1080 /*screenWidth, screenHeight*/);
  /* smooth commented out by preprocessor */; //funcao de antialiasing
  center_x = screenWidth/2-width/2; //centrar a janela no eixo X
  center_y = screenHeight/2-height/2; //centrar a janela no eixo Y
  surface.setLocation(center_x, center_y); //set location of canvas to center of screen resolution
  imageMode(CENTER); //funcao para centrar o spawn de imagens
  rectMode(CENTER); //função para centrar o spawn de rectângulos
  textAlign(CENTER); //funcao para alinhar o texto ao centro 
  noStroke(); //funcao para retirar o Stroke das figuras geometricas
//Inicializar Objetos
  score = 0;
  lives = 3;
  m = new Menu(width/2, height/2); //menu
  pm = new PlayerShipMenu(width/2, height/2); //menu para escolha de "nave" usa bala e imagem diferente
  c1 = new CloudsGen("/assets/images/cloud1.png", 100, random(height)); //nuvem 1
  c2 = new CloudsGen("/assets/images/cloud2.png", 200, random(height)); //nuvem 2
  c3 = new CloudsGen("/assets/images/cloud3.png", 300, random(height)); //nuvem 3
  c4 = new CloudsGen("/assets/images/cloud4.png", 400, random(height)); //nuvem 4
  c5 = new CloudsGen("/assets/images/cloud5.png", 500, random(height)); //nuvem 5
  p1 = new Player("/assets/images/first_ship_cs.png", -200, height/2); //player 1 //spawn fora do canvas para animar a entrada do player no jogo
  e1 = new ArrayList<Enemy>(); //enemy 1 (necessario tornar isto num array list de waves para attack)
  e1.add(new Enemy("/assets/images/AlienSpaceship.png", width-300, height-300, 150));
  e1.add(new Enemy("/assets/images/AlienSpaceship_secondcs.png", width-300, height-300, 150));
  e1.add(new Enemy("/assets/images/AlienSpaceship_thirdcs.png", width-300, height-300, 150));
  hits = e1.get(p1.level).health/p1.dmg;
}
 public void draw() { //desenhar os elementos do programa no ecra mediante condicoes especificadas
  m.start(); //verifica presses
  if (m.i.active) { //instrucoes ativos
    m.i.drawme();
    m.i.back.drawme();
  } if (pm.state && score >= hits) { //player menu = escolha de cor para a nave (desbloqueia com x score)
    pm.drawme();
    pm.back.drawme();
    pm.ship1.drawme();
    pm.ship2.drawme();
    pm.ship3.drawme();
  } if (m.highscore.active) { //highscore ativos
    m.highscore.drawme();
    m.highscore.back.drawme();
  } if (m.state) { //menu ativo
    m.start.drawme();
    m.exit.drawme();
    m.highscorebttn.drawme();
    m.instructionsbttn.drawme();
  } if (displayGame) { //jogo ativo
    m.background.drawme();
    m.back.drawme(); //desenhar o botão de pausa
    c1.drawme(); //desenhar e mover nuvem1
    c2.drawme(); //desenhar e mover nuvem2
    c3.drawme(); //desenhar e mover nuvem3
    c4.drawme(); //desenhar e mover nuvem4
    c5.drawme(); //desenhar e mover nuvem5
    p1.drawme(); //desenhar e mover o player1
    e1.get(p1.level).drawme(); //desenhar e mover o inimigo
    score(); //incrementar score
  }
}
 public void keyPressed() {
  if (key == ' ') p1.shoot(); // disparar a bala ate width, se pressionado novamente, da reset a posicao da bala e volta a desenhar ate width
//codigo para movimento importado do exemplo fornecido pelo professor
  if(key == 's'|| key == 'S') p1.moveDown = true;
  if(key == 'w'|| key == 'W') p1.moveUp = true;
  if(key == 'a'|| key == 'A') p1.moveLeft = true;
  if(key == 'd'|| key == 'D') p1.moveRight = true;
}
 public void keyReleased() {
  if(key == 's'|| key == 'S') p1.moveDown = false;
  if(key == 'w'|| key == 'W') p1.moveUp = false;
  if(key == 'a'|| key == 'A') p1.moveLeft = false;
  if(key == 'd'|| key == 'D') p1.moveRight = false;
}
 public void healthcheck(){ //verificar se o player colidiu com o inimigo // passar isto para o codigo do player noutra funcao e correr dentro da funcao movimento. // tambem preciso de colocar as colisoes a funcionar em forma de retangulo (mais simples de implementar do que poligonos ou ellipse)
  //put here code for checking between bullet and enemy
  // float distX = p1.posX - e1.get(p1.level).posX;
  // float distY = p1.posY - e1.get(p1.level).posY;
  // float distance = sqrt((distX*distX) + (distY*distY)); //(PI * (190/2) * (80/2)) + (PI * (150/2) * (70/2));
  // if (distance <= distX + distY) p1.health -= 10;//if distance is less than PI than the radius of the enemy, then the player loses health (10)
  // if (distance <= distX + distY) e1.health -= p1.b1.damage;
}
//acrescentar pontuacao na tabela
 public void score() {
  textSize(32); // era fixe colocar isto numa funcao propria para mostrar no ecra, em vez de estar aqui perdido 
  text("Score: "+score, m.i.posX, height/8);
  if (p1.b1.get(p1.level).enemycheck()) score++;
  if (score == 10 && e1.get(p1.level).health < 10) {
    p1.level = 1;
    hits = e1.get(p1.level).health/p1.dmg;
  }
  if (score == 20 && e1.get(p1.level).health < 10) {
    p1.level = 2;
    hits = e1.get(p1.level).health/p1.dmg;
  }
}
 public void mousePressed() { // quando clicar no botao do rato dentro das condicoes especificadas(dentro dos limites da imagem do botao)
  if(m.start.press()) m.start.pressed = true;
  if(m.exit.press()) m.exit.pressed = true;
  if(m.back.press()) m.back.pressed = true;
  if(m.instructionsbttn.press()) m.instructionsbttn.pressed = true;
  if(m.i.back.press()) m.i.back.pressed = true;
  if(m.highscorebttn.press()) m.highscorebttn.pressed = true;
  if(m.highscore.back.press()) m.highscore.back.pressed = true;
}
class Background {
//propriedades
    float posX, posY;
    PImage img;
//construtor
    Background(String n, float x, float y) {
        img = loadImage(n);
        posX = x;
        posY = y;
    }
//metodo desenhar para o canvas
     public void drawme() {
        image(img, posX, posY);
    }
}
class Bullets {
  //propriedades
  PImage bullet;
  float posX, posY, tam, damage;
  //construtor
  Bullets(String n, float x, float y, float t) {
    bullet = loadImage(n);
    posX = x;
    posY = y;
    tam = t;
    damage = 10;
  }
  //desenhar as balas no ecra
   public void drawme() {
    //redimensionar a imagem da bala para o tamanho pretendido
    bullet.resize(PApplet.parseInt(tam), 25);
    //desenhar imagem da bala no canvas
    image(bullet, posX, posY);
    if (p1.level == 1) damage = 20;
    if (p1.level == 2) damage = 30;
    moveme();
  }
  //mover a bullet a partir da posicao do player
   public void moveme() {
    //Para a bala precorrer o Y desde o ponto de spawn ate ao final do Y do canvas
    if (posY < width-tam) {
      posX += tam;
    }
  }
  //verificar se a posicao X e Y do enimigo, corresponde a mesma posicao X e Y da bala, em ordem a contar como HIT
  public boolean enemycheck() {
    if (dist(posX+tam/2, posY+tam/2, e1.get(p1.level).posX+e1.get(p1.level).tam/2, e1.get(p1.level).posY+e1.get(p1.level).tam/2) < tam) {
      return true;
    }
    return false;
  }
}
class Button {
//properties
PImage button;
float posX, posY, tam1, tam2;
boolean pressed;
//construtor
    Button(String name, float x, float y) {
        button = loadImage(name);
        //button.resize(button.width/2, button.height/2);
        tam1 = 102;
        tam2 = 70;
        posX = x;
        posY = y;
        pressed = false;
    }
     public void drawme() {

        

        image(button, posX, posY); //colocar isto na liunha 21 depois
        //this code below is to check the hitboxes of the buttons
        //fill(250, 0, 0, 70); //manual debug
        //rect(posX, posY, tam1, tam2); //manual debug
    }
     public boolean press() { //check mousepress on button, return value for pressed button
        if(mouseX > posX-tam1 && mouseX < posX + tam1 && mouseY > posY-tam2 && mouseY < posY + tam2) {
            pressed = true;
        }
        return pressed;
    }
}
//creating the class for cloud generating
class CloudsGen {
//properties
  PImage img; //declaring varible to save images
  float posX, posY; //positions X and Y on canvas
//constructor
  CloudsGen(String nome, float x, float y) {
    img = loadImage(nome); //inicializing the variable, with the value passed through the CloudShooter.pde values.
    posX = x;
    posY = y;
  }
//method used to draw the objects on the canvas
   public void drawme() {
    image(img, posX, posY); //function image to draw the image with three specified parameters inside
    move(); //calling the method move
    if (!m.state) reset(); //calling the method reset
  }
//method used to make the object run through X and randomly change height
   public void move() {
    if (posX > -img.width) {
      posX -= random(2, 25); // acrescentar codigo noise
    } else {
      posX = width;
      posY = random(height);
    }
  }
   public void reset() {//reset da posicao X e Y das nuvens quando o menu esta ativo
    posX = width; 
    posY = height;
  }
}
class Enemy {
  //propriedades
  float trand = 5;
  float tsmoothed;
  PImage img;
  float posX, posY, vel, damage, tam;
  int health;
  //constructor
  Enemy(String nome, float x, float y, int t) {
    img = loadImage(nome);
    posX = width-tam;
    posY = height/2;
    tam = t;
    vel = 5;
    damage = 5;
    health = 100;
  }
   public void drawme() {
    img.resize(PApplet.parseInt(tam), PApplet.parseInt(tam)); //redimensiona a imagem
    if(health > 0) image(img, posX, posY);
    fill(255, 0, 0, 200);
    //rect(posX, posY+10, 150, 70); //hitbox debug only 
    textSize(24);
    text("Health: " + health, posX, posY-40);
    move();
  }
//necessito de fazer com que o enimigo se multiplique a cada posX completo.
//usar um array de objetos de enimigos onde vao dando spawn a cada posX completo.
   public void move() { //fazer inimigo andar pelo canvas variando velocidade horizontal e posicao vertical aleatoria
    tsmoothed = noise(trand); //posicao vertical dinamica, dificuldade 0
    tsmoothed = map(tsmoothed, 0, 1, tam, width-tam);
    posY = tsmoothed;
    if (posY < 90) posY += vel; //nao sair do canvas para baixo
    if (posY > 980) posY -= vel; //nao sair do canvas para cima
    if (posX < 0 ) {
      posX = width + tam;
    } else {
      posX -= vel;
      if (p1.level == 0) {
        trand += 0.002f;
      }else if (p1.level == 1) {
        trand += 0.09f;
      }else if (p1.level == 2) {
        trand += 0.3f;
      }
    }
    healthcheck(); //verificar a cada movimento a vida do inimigo
  }
   public void healthcheck() { //when it, turns red
    if(health < health/2){
        img.loadPixels();
        for(int x = 0; x < img.width; x++) {
            for(int y = 0; y < img.height; y++) {
                if(blue(img.pixels[x+y*img.width]) > 128) {
                    img.pixels[x+y*img.width] = color(128, 0, 0);
                }
            }
        }
        img.updatePixels();
    }
    if (p1.level == 1) health = 200;
    if (p1.level == 2) health = 300;
  }
}
class Highscore {
//propriedades
Table table;
boolean active;
Button back;
Background background;
//construtor
Highscore() {
    background = new Background("/assets/images/background1080p.png", width/2, height/2);
    active = false;
    back = new Button("assets/images/back_button.png", width-250, 80);//botao para retroceder
    //inicializar a tabela para armazenar highscore
    table = new Table();
    //adicionar colunas na tabela
    table.addColumn("id");
    table.addColumn("score");
}
     public void drawme() {
        background.drawme();
        if(active);
        loadData();
    }
     public void loadData() { //carregar a tabela com os valores anteriores.
        table = loadTable("data/highscore.csv", "header");
        int contador = table.getRowCount();
        //print all the data from csv
        fill(255, 0, 0);
        textSize(34);
        for (int i = 0; i < contador; i++) {
            text("ID: " + table.getRow(i).getInt("id")+" SCORE: " + table.getRow(i).getInt("score"), width/2, 35 + i*35);
        }
    }
     public void addData() { //adicionar dados na tabela
        if (score > 0) {
            TableRow newRow = table.addRow();
            //adicionar linhas na tabela
            newRow.setInt("id", table.lastRowIndex()+1);
            newRow.setInt("score", score);
        } else println("no data to save");
    }
     public void saveData() {
        saveTable(table, "data/highscore.csv"); //guardar os dados da tabela no ficheiro
    }
     public int top5() { // tenho que por isto a funcionar para mostrar pelo botao highscore
        int result = 0;
        //ler o ficheiro e determinar o top 5   
        return result;
    }
}
class Instructions {
//propriedades
float posX, posY;
boolean active;
String text1 = "1. Use WASD to move the player";
String text2 = "2. Use SPACE to fire a bullet at the enemy";
String text3 = "3. If you get hit by an enemy, you lose a life";
String text4 = "4. If you run out of lives, you lose";
String text5 = "5. If you get to certain highscore milestones, you unlock more types of bullets that deal more damage.";
int purple = color(0xFFCE0FFA);
int white = color(0xFFFBEAFF);
int black = color(0);
int red = color(0xFFFA0000);
Button back;
//construtor
    Instructions(float x, float y) {
        posX = x;
        posY = y;
        active = false;
        back = new Button("assets/images/back_button.png", width-250, 80);
    }
     public void drawme() {
        if (active);
            m.background.drawme();
            fill(red);
            textSize(64);
            text("Instructions", posX, height/4);
            textSize(32);
            fill(black);
            text(text1, posX, height/2);
            text(text2, posX, height/2 + 50);
            text(text3, posX, height/2 + 100);
            text(text4, posX, height/2 + 150);
            text(text5, posX, height/2 + 200);
    }
}
//esta classe vai servir para colocar o array de balas para o jogador
class Magazine {
//properties
    //ArrayList <Bullets> b;
//constructor
    Magazine(){
        //Bullets b = new ArrayList();
    }
}
class Menu{
//propriedades
    float posX, posY;
    boolean state;
    Button start, exit, back, highscorebttn, instructionsbttn, credits;
    Highscore highscore;
    Background background;
    Instructions i;
//construtor 
Menu(float x, float y) {
    posX = x;
    posY = y;
    state = true;//estado ativo ou desativo do menu.
    background = new Background("assets/images/background1080p.png", width/2, height/2);//background do menu
    start = new Button("assets/images/start_button.png", width/2 - 350, height/2 - 100);//botao para comecar o jogo
    exit = new Button("assets/images/exit_button.png", width/2 + 250, height/2 - 100);//botao para sair do jogo.
    back = new Button("assets/images/back_button.png", width-250, 80);//botao para retroceder
    instructionsbttn = new Button("assets/images/instructions_button.png", width/2 - 250, height/2 + 200);//botao para entrar nas instrucoes
    highscorebttn = new Button("assets/images/highscores_button.png", width/2 + 150, height/2 + 200);//botao para entrar na tabela de highscores
    highscore = new Highscore();//objeto que contem a informacao da tabela .csv Highscores
    i = new Instructions(width/2, center_y); //objeto contem o desenho (texto) das instructucoes.
    highscore.loadData();
}
     public void start() { //desenhar e verificar estado dos botões
        background.drawme();
        if(state){  //verficar estado pressed de cada botao
            if (start.pressed) displayGame = true;  //se o botao start nao estiver a ser pressionado entao o menu continua a ser mostrado.
            if (exit.pressed) { ///pressionar botao exit guarda highscore e sai do jogo
                highscore.saveData();
                exit();
            } 
        }
        if(back.pressed) {
            highscore.addData();
            highscore.saveData();
            displayGame = false;
            p1.posX = -300; //para o player ir para a posicao inicial e fazer novamente a animacao de entrada
            p1.posY = height/2; //mesma coisa da linha de cima, mas para o eixo Y.
            p1.moveUnLock = false; //para a mesma coisa acima mencionada.
            start.pressed = false; 
            back.pressed = false;
        }
        if(instructionsbttn.pressed) {
            state = false;
            i.active = true;
        }
        if (i.back.pressed) {
            i.active = false;
            state = true;
        }
        if (highscorebttn.pressed) {
            state = false;
            highscore.active = true;
            highscorebttn.pressed = false;
        }
        if (highscore.back.pressed) {
            highscore.active = false;
            state = true;
            highscore.back.pressed = false;
        }
    }
}
class Player {
//Properties
  PImage img; //sprite normal
  float posX, posY, tam, vel, health, dmg;
  int level;
  boolean moveUp, moveDown, moveLeft, moveRight, moveUnLock; //booleanas para controlar o movimento do player
  public ArrayList<Bullets> b1; //bullets
//Constructor
  Player(String n, float x, float y) {
    img = loadImage(n); //carrega imagem especificada
    posX = x;
    posY = y;
    tam = 350/32; //tamanho = img resized
    vel = 350/16; //velocidade para movimentar a nave
    health = 100;
    dmg = 10; //dano da bala no nivel 0, se o level subir, tem ifs em baixo para mudar o valor desta variavel.
    moveUnLock = true;
    moveDown  = false;
    moveLeft  = false;
    moveRight = false;
    moveUp = false;
    level = 0;  //nivel atual de dificuldade
    b1 = new ArrayList<Bullets>(); //bullets
    b1.add(new Bullets("assets/images/bullet_out_of_shell.png", -650, -650/2, 50)); //bullet tipo 1
    b1.add(new Bullets("assets/images/second_bullet_out_of_casing.png", -650, -650/2, 50)); //bullet tipo 2
    b1.add(new Bullets("assets/images/third_bullet_out_of_casing.png", -650, -650/2, 50)); //bullet tipo 3
  }
   public void drawme() { //spawn da imagem mediante parametros indicados + resize para tamanho pretendido
    b1.get(level).drawme(); //desenhar as balas
    b1.get(level).moveme(); //mover as balas
    img.resize(350, 225); // redimensionar imagem das balas para tamanho do cano da nave
    if(health > 0) image(img, posX, posY); //display sprite of player ship with position and health check updated every tick
    fill(255, 0, 0, 200);
  //rect(posX+20, posY+10, 190, 80);
    textSize(24);
    text("Health: " + health, posX+20, posY-40);
    moveme(); //mover o player1 //this now includes an animation on START to introduce the player into the canvas.
    damage(); //check if player hit the enemy and apply damage to enemy
  } 
   public void damage() { //aplicar dano ao enimigo da bala da nave, consoante o nivel atual //http://jeffreythompson.org/collision-detection/rect-rect.php
    if(dist(e1.get(level).posX, e1.get(level).posY, b1.get(level).posX, b1.get(level).posY) < b1.get(level).tam) {
      if (level == 1) dmg = 20;
      if (level == 2) dmg = 30;
      e1.get(level).health -= dmg;
    }
  }
   public void shoot () { // mover a bala, desenhar a bala posicionar a imagem da bala
    b1.get(level).posX = posX-img.width/8.5f;
    b1.get(level).posY = posY+img.height/5.8f;
    b1.get(level).drawme();
  }
   public void lives (){
    if (lives == 0) { //game over
    } else if (health <= 0){
        lives--;
        health = 100;
      }
  }
   public void moveme() {  //validar posicao e incremento da mesma caso tecla seja pressionada
    //verifica se o player saiu de qq coordenada, x,y,-x,-y para retomar o player a sua area de jogo.
    if(posX < 200) posX += 10;
    if(posY < 100) posY += 10;
    if(posX > 1720) posX -= 10;
    if(posY > 980) posY -= 10;
    if (posX == 200) moveUnLock = true; //animacao inicial para o player sair do spawn area e ir ate a area de jogo
    //println(moveUnLock); usei isto para debug apenas. 
    //codigo da linha 80 a 84 importado do exemplo do professor para movimento + suave
    if(moveUnLock) { //lock player movement
      if (moveLeft) posX -= vel;  // "if(left == true)" igual a "if(left)"
      else if (moveRight) posX += vel;
      else if (moveUp) posY -= vel;
      else if (moveDown) posY += vel;
    }
  }
}
class PlayerShipMenu {
//propriedades
float posX, posY;
boolean state;
Button ship1, ship2, ship3;
Background background;
Button back;
    //construtor 
    PlayerShipMenu(float x, float y) {
        background = new Background("assets/images/background1080p.png", 0, 0);
        posX = x;
        posY = y;
        state = false;
        back = new Button("assets/images/back_button.png", width - 250, 80); //botão para voltar atrás
        ship1 = new Button("assets/images/first_ship_cs.png", width/2 - 500, height/2 - 100); //image to be changed in the near future
        ship2 = new Button("assets/images/first_ship_secondcs.png", width/2 + 100, height/2 - 100);    //método usado para desenhar os botões
        ship3 = new Button("assets/images/first_ship_thirdcs.png", width/2 + 300, height/2 - 100);
    } 
     public void drawme() {
        if (state) {
            background.drawme();
            ship1.drawme();
            ship2.drawme();
            ship3.drawme();
            shipColor();
            p1.drawme();
        }
    }
    //adicionar aqui metodo para escolher a nave e a bala do player // desbloqueaveis com highscore 
     public void shipColor() {
        //logica para escolha na nave + return da string correta para definir
        if(state && m.state) {
            if(ship1.press()) p1.img = loadImage("assets/images/first_ship_cs_pressed.png");
            if(ship2.press()) p1.img = loadImage("assets/images/first_ship_secondcs_pressed.png");
            if(ship3.press()) p1.img = loadImage("assets/images/first_ship_thirdcs_pressed.png"); 
        }
    }
}


  public void settings() { fullScreen(0);
smooth(8); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "CloudShooter" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
