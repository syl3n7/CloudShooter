/* autogenerated by Processing revision 1276 on 2022-12-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class CloudShooter extends PApplet {



//inicializar objetos
Menu m;
CloudsGen c1;
CloudsGen c2;
CloudsGen c3;
PlayerShipMenu pm;
public Player p1;
Bullets b1;
Enemy e1;
public int score = 0;
public int lives = 3;
float bgc = 0;
public int center_x, center_y;
boolean bgcUpperLimit = false; //variavel de controlo para incremento/decremento da cor do background

//codigo apenas corrido 1x (inicio do programa)
 public void setup() {  
//https://forum.processing.org/one/topic/dynamic-screen-background-resize-need-guidance.html
//vou provavelmente precisar do link acima para colocar o tamanho da imagem de fundo dinamica 

//dinamic window size begin (without borders)
  surface.setTitle("CloudShooter by Catarina & Claudio"); //titulo da janela
  /* size commented out by preprocessor */;
  frameRate(60); //especificar framerate a usar
  Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
  int screenWidth = screenSize.width;
  int screenHeight = screenSize.height;
  surface.setSize(1920, 1080/*creenWidth, screenHeight*/);
  /* smooth commented out by preprocessor */;
  center_x = screenWidth/2-width/2;
  center_y = screenHeight/2-height/2;
  surface.setLocation(center_x, center_y); //set location of canvas to center of screen resolution
  imageMode(CENTER); //funcao para centrar o spawn de imagens
  rectMode(CENTER); //função para centrar o spawn de rectângulos
  textAlign(CENTER);
  noStroke();
//dinamic window size end

  /*Inicializar Objetos ⬇️*/
  //menu
  m = new Menu(width/2, height/2);
  //menu para escolha de "nave" usa bala e imagem diferente
  pm = new PlayerShipMenu(width/2, height/2);
  //nuvem 1
  c1 = new CloudsGen("/assets/images/cloud1.png", 100, random(height));
  //nuvem 2
  c2 = new CloudsGen("/assets/images/cloud2.png", 200, random(height));
  //nuvem 3
  c3 = new CloudsGen("/assets/images/cloud3.png", 300, random(height));
  //player 1
  p1 = new Player("/assets/images/first_ship_cs.png", -200, height/2);//spawn fora do canvas para animar a entrada do player no jogo
  //bullet 1
  b1 = new Bullets("assets/images/bullet_out_of_shell.png", -650, -650/2, 100);
  //enemy 1
  e1 = new Enemy("/assets/images/ovni.png", (width - 300), (height - 300), 150, 5, 100);
}

//desenhar os elementos do programa no ecra
 public void draw() {
  //calls menu
  m.start(); //verifica presses
  if (m.state) {
    m.start.drawme(); //use loadtable to load the previous highscores
    m.exit.drawme();
    m.highscorestable.drawme();
    m.instructions.drawme();
    if(m.i.active == true && pm.state == false) m.i.drawme();
    if(pm.state == true && pm.state == false) pm.drawme();
  } //add a button to acess the highscores // add a button to acess instructions
  
  if(m.state == false){
    //claudio fez esta parte do codigo
    if (bgc == 250) bgcUpperLimit = true;//dynamic background start
    if (bgcUpperLimit == false) background(0, 20, bgc++, 0); //se parar de dar update ao background, funciona como um botao de pausa, maybe later ?
    if (bgc == 25) bgcUpperLimit = false; 
    if (bgcUpperLimit == true) background(0, 20, bgc--, 0);//end of dynamic background
    m.back.drawme(); //desenhar o botão de pausa
    c1.drawme(); //desenhar nuvem1
    c2.drawme(); //desenhar nuvem2
    c3.drawme(); //desenhar nuvem3
    c1.move(); //mover a nuvem1
    c2.move(); //mover a nuvem2
    c3.move(); //mover a nuvem3
    p1.drawme(); //desenhar o player1
    p1.moveme(); //mover o player1 //this now includes an animation on START to introduce the player into the canvas.
    b1.drawme(); //desenhar as balas
    b1.moveme(); //mover as balas
    e1.drawme(); //desenhar o inimigo
    e1.move(); //Bmover o inimigo
    //  e1.healthcheck(); //verificar se o inimigo morreu ou nao
    score(); //calls"b1.enemycheck();" ou seja: verificar se a bala atingiu o inimigo e acrescentar valor ao score
  }
}

 public void keyPressed() {
  if (key == ' ') {
    p1.shoot();
  }

  if(key == 's'|| key == 'S') p1.moveDown = true;
  if(key == 'w'|| key == 'W') p1.moveUp = true;
  if(key == 'a'|| key == 'A') p1.moveLeft = true;
  if(key == 'd'|| key == 'D') p1.moveRight = true;
}

 public void keyReleased() {
  if(key == 's'|| key == 'S') p1.moveDown = false;
  if(key == 'w'|| key == 'W') p1.moveUp = false;
  if(key == 'a'|| key == 'A') p1.moveLeft = false;
  if(key == 'd'|| key == 'D') p1.moveRight = false;
}

//codigo importado do exemplo fornecido pelo professor para o movimento ser + suave
/*void keyPressed() {
  if(key == 'j' || key == 'J') plane.left = true;
  if(key == 'l' || key == 'L') plane.right = true;
  if(key == 'i' || key == 'I') plane.up = true;
  if(key == 'k' || key == 'K') plane.down = true;
}
void keyReleased() {
  if(key == 'j' || key == 'J') plane.left = false;
  if(key == 'l' || key == 'L') plane.right = false;
  if(key == 'i' || key == 'I') plane.up = false;
  if(key == 'k' || key == 'K') plane.down = false;
}
*/

//acrescentar pontuacao na tabela
 public void score() {
  if (b1.enemycheck()) {
    score++;
  }
}

 public void mousePressed() { // quando clicar no botao do rato dentro das condicoes especificadas(dentro dos limites do "canvas" da imagem do botao), iniciar jogo ou sair do jogo
  if(m.start.press()) m.start.pressed = true; //m.start.button = loadImage("assets/images/pressed_start_button.png");
  if(m.exit.press()) m.exit.pressed = true; //m.exit.button = loadImage("assets/images/pressed_exit_button.png");
  if(m.back.press()) m.back.pressed = true; //m.back.button = loadImage("assets/images/pressed_back_button.png");
}

/*void mouseReleased() {
  if(m.start.press()) {
    m.start.pressed = true;
    m.start.button = loadImage("assets/images/start_button.png");
  }
  //println(m.start.pressed);
  if(m.exit.press()) {
    m.exit.pressed = true;
    m.exit.button = loadImage("assets/images/exit_button.png");
  }
  //println(m.exit.pressed);
  if(m.back.press()) {
    m.back.pressed = true;
    m.back.button = loadImage("assets/images/back_button.png");
  }
  //println("state butao back "+m.back.pressed);//debug
  //println("state menu "+m.state);//debug
}*/
class Background {
    //propriedades
    float posX, posY;
    PImage img;
    //construtor
    Background(String n, float x, float y) {
        img = loadImage(n);
        posX = x;
        posY = y;
    }
    //metodo desenhar para o canvas
     public void drawme() {
        image(img, posX, posY);
    }

}
class Bullets {

  //propriedades
  PImage bullet;
  float posX, posY, tam;

  //construtor
  Bullets(String n, float x, float y, float t) {
    bullet = loadImage(n);
    posX = x;
    posY = y;
    tam = t;
  }

  //desenhar as balas no ecra
   public void drawme() {
    //redimensionar a imagem da bala para o tamanho pretendido
    bullet.resize(PApplet.parseInt(tam), 25);
    //desenhar imagem da bala no canvas
    image(bullet, posX, posY);
  }

  //mover a bullet a partir da posicao do player
   public void moveme() {
    //Para a bala precorrer o Y desde o ponto de spawn ate ao final do Y do canvas
    if (posY < width-tam) {
      posX += tam;
    }
  }
  //verificar se a posicao X e Y do enimigo, corresponde a mesma posicao X e Y da bala, em ordem a contar como HIT
   public boolean enemycheck(){
    if (dist(b1.posX+b1.tam/2, b1.posY+b1.tam/2, e1.posX+e1.tam/2, e1.posY+e1.tam/2) < tam) {
      return true;
    }
    return false;
  }
}
class Button{

//properties
PImage button;
float posX, posY, tam1, tam2;
boolean pressed;

    Button(String name, float x, float y){
        button = loadImage(name);
        //button.resize(button.width/2, button.height/2);
        tam1 = 210;
        tam2 = 130;
        posX = x;
        posY = y;
        pressed = false;
    }

     public void drawme(){
        image(button, posX, posY);//colocar isto na liunha 21 depois
        //this code below is to check the hitboxes of the buttons
        fill(255, 0, 0, 100); //manual debug
        rect(posX, posY, tam1, tam2); //manual debug
    }

    //check mousepress on button, return value for pressed button
     public boolean press(){
        if(mouseX > posX && mouseX < posX + tam1 && mouseY > posY && mouseY < posY + tam2*2 ){
            pressed = true;
        }
        return pressed;
    }
}
//creating the class for cloud generating
class CloudsGen {

//properties
  PImage img; //declaring varible to save images
  float posX, posY; //positions X and Y on canvas

//constructor
  CloudsGen(String nome, float x, float y) {
    img = loadImage(nome); //inicializing the variable, with the value passed through the CloudShooter.pde values.
    posX = x;
    posY = y;
  }

//method used to draw the objects on the canvas
   public void drawme() {
    image(img, posX, posY); //function image to draw the image with three specified parameters inside
  }

//method used to make the object run through X and randomly change height
   public void move() {
    if (posX > -img.width) {
      posX -= random(2, 25); // acrescentar codigo noise
    } else {
      posX = width;
      posY = random(height);
    }
  }
}
class Enemy {

  //propriedades
  float dp = 37;
  float trand = 5;
  float tsmoothed;
  PImage img;
  float posX, posY, vel, damage, tam;
  int health;
  float mediaY = height/2;
  //constructor
  Enemy(String nome, float x, float y, int t, float v, float d) {
    img = loadImage(nome);
    posX = width-tam;
    posY = 0;
    tam = t;
    vel = v;
    damage = d;
    health = 100;
  }
//necessito de chamar recursivamente esta funcao para que o jogador possa eliminar o inimigo e ele continue a dar spawn
   public void drawme() {
    img.resize(PApplet.parseInt(tam), PApplet.parseInt(tam)); //redimensiona a imagem
    image(img, posX, posY);
  }

//necessito de fazer com que o enimigo se multiplique a cada posY completo 

//fazer enimigo andar pelo canvas variando velocidade horizontal e posicao vertical aleatoria
   public void move() {
    //tam = randomGaussian();
    //tam = tam * dp + mediaY;
    tsmoothed = noise(trand); //posicao vertical dinamica, dificuldade 0
    tsmoothed = map(tsmoothed, 0, 1, tam, width-tam);
    posY = tsmoothed;

    if (posX < 0) {
      posX = width + tam;
    } else {
      posX -= vel;
      trand += 0.07f;
    }
  }

/* placeholder para verificar se foi atingiho pela bala*/
  /* placeholder code 
  void healthcheck() {

    if (health <= 0) {
      enemy.hide();
    }

  }
  */
}
class Highscore{

//propriedades
Table table;

//construtor
    Highscore(){
        //inicializar a tabela para armazenar highscore
        table = new Table();
        //adicionar colunas na tabela
        table.addColumn("id");
        table.addColumn("score");
    }

     public void addData(){
        TableRow newRow = table.addRow();
        //adicionar linhas na tabela
        newRow.setInt("id", table.lastRowIndex()+1);
        newRow.setInt("score", score);
    }

     public void saveData(){
        //guardar os dados da tabela no ficheiro
        saveTable(table, "data/highscore.csv");
    }

    // tenho que por isto a funcionar para mostrar pelo botao highscore
     public int top5(){
        int result = 0;
        //ler o ficheiro e determinar o top 5
        
        return result;
    }
}
class Instructions {
//propriedades
float posX, posY;
boolean active;
String text1 = "1. Use WASD to move the player";
String text2 = "2. Use SPACE to fire a bullet at the enemy";
String text3 = "3. If you get hit by an enemy, you lose a life";
String text4 = "4. If you run out of lives, you lose";
String text5 = "5. If you get to certain highscore milestones, you unlock more types of bullets that deal more damage.";
int purple = color(0xFFCE0FFA);
int white = color(0xFFFBEAFF);
int red = color(0xFFFA0000);
Button back;

//construtor
    Instructions(float x, float y, boolean b){
        posX = x;
        posY = y;
        active = b;
        back = new Button("assets/images/back_button.png", width-250, 10);
    }

     public void drawme(){
        if (active);
        fill(purple);
        rect(posX,posY,width,height);
        fill(red);
        textSize(64);
        text("Instructions", posX, height/4);
        textSize(32);
        fill(white);
        text(text1, posX, height/2);
        text(text2, posX, height/2 + 50);
        text(text3, posX, height/2 + 100);
        text(text4, posX, height/2 + 150);
        text(text5, posX, height/2 + 200);
        if(m.back.pressed){
            active = false;
        }
    }
}
class Menu{

//propriedades
float posX, posY;
boolean state;
Button start, exit, back, highscorestable, instructions, credits;
Highscore highscore;
Background background;
Instructions i;

    //construtor 
    Menu(float x, float y) {
        posX = x;
        posY = y;
        state = true;
        //background = new Background("assets/menu.png", 0, 0);
        start = new Button("assets/images/start_button.png", width/2 - 500, height/2 - 100);
        exit = new Button("assets/images/exit_button.png", width/2 + 100, height/2 - 100);
        back = new Button("assets/images/back_button.png", width-250, 10);
        instructions = new Button("assets/images/instructions_button.png", width/2 - 500, height/2 + 200);
        highscorestable = new Button("assets/images/highscores_button.png", width/2 + 100, height/2 + 200);
        highscore = new Highscore();
        i = new Instructions(center_x, center_y, false);
    }

    //método usado para desenhar os botões
     public void start() {
        //background.drawme();
        //verficar estado pressed de cada botao
        if(state){
              //testing dynamic background color
            if (bgc == 250) bgcUpperLimit = true;
            if (bgcUpperLimit == false) background(bgc++, 0, bgc, 0); //se parar de dar update ao background, funciona como um botao de pausa, maybe later ?
            if (bgc == 5) bgcUpperLimit = false; 
            if (bgcUpperLimit == true) background(bgc--, 0, bgc, 0);

            if (start.pressed) state = false;//se o botao start nao estiver a ser pressionado entao o menu continua a ser mostrado.
            if (exit.pressed) { ///pressionar botao exit guarda highscore e sai do jogo
                highscore.saveData();
                exit();
            } 
        }
        if(back.pressed) {
            highscore.addData();
            state = true;
            p1.posX = -300; //para o player ir para a posicao inicial e fazer novamente a animacao de entrada
            p1.moveUnLock = false; //para a mesma coisa acima mencionada.
            start.pressed = false;
            back.pressed = false;
        }
        if(instructions.pressed) {
            i.active = true;
        }
    }
} 
class Player {
  //Properties
  PImage img; //sprite normal
  float posX, posY, tam, health;
  boolean moveUp, moveDown, moveLeft, moveRight, moveUnLock; //booleanas para controlar o movimento do player
  //Constructor
  Player(String n, float x, float y) {
    img = loadImage(n); //interligar isto ⬇️ ao playership menu
    //imgUp = "assets/images/first_ship_secondcs.png";
    //imgDown = loadimage(imgDown);
    //imgLeft = loadimage(imgLeft);
    //imgRight = loadimage(imgRight);
    posX = x;
    posY = y;
    tam = 350/16;//tamanho = img resized / 8
    health = 100;
    moveUnLock = true;
    moveDown  = false;
    moveLeft  = false;
    moveRight = false;
    moveUp = false;
  }

  //spawn da imagem mediante parametros indicados + resize para tamanho pretendido
   public void drawme() {
    img.resize(350, 225);
    if(health > 0) image(img, posX, posY); //display sprite of player ship with position and health check updated every tick
    //checkDirection();
  }

  //abandoned idea of changing sprite with direction, we instead opted for alowing the player to chose from sprites aka customization, unlocked with x amount of highscore.
  //check direction and change the sprite acordingly
  //  void checkDirection() {
  //   if(moveUp) {
  //     img = loadImage(imgUp); //missing the sprite
  //   }
  //   if(moveDown) {
  //     //img = loadImage(imgDown); //missing the sprite
  //   }
  //   if(moveLeft) {
  //     //img = loadImage(imgLeft); //missing the sprite
  //   }
  //   if(moveRight) {
  //     //img = loadImage(imgRight); //missing the sprite
  //   } 
  // }

//check decision on bullet type // should make this to work with score or dificulty. or both !
  // void bulletChoice() {
  //   if(buttonTBD.press) return = "/assets/images/bullet1.png";
  //   if(buttonTBD.press) return = "/assets/images/bullet2.png";
  //   if(buttonTBD.press) return "/assets/images/bullet3.png";
  // }

  //damage radius
   public void damage() {
    //http://jeffreythompson.org/collision-detection/rect-rect.php
    //ler novamente o link acima. necessito de fazer a verificacao de colisao. 
    // i probably need to use the ellipse way to calculate this 
  }

   public void shoot () {  
    b1.posX = posX+img.width/2.5f;
    b1.posY = posY+img.height/3.7f;
    b1.moveme();
  }

  //validar posicao e incremento da mesma caso tecla seja pressionada
   public void moveme(){
    //player animation from outside of the canvas to the "spawn" position where the player can take over the controls.
    if(posX < 200) posX += 10;
    if (posX == 300) moveUnLock = true;
    if(!moveUnLock); //lock player movement
    println(moveUnLock);
    if (moveLeft) posX -= tam;  // "if(left == true)" igual a "if(left)"
    else if (moveRight) posX += tam;
    else if (moveUp) posY -= tam;
    else if (moveDown) posY += tam;
  }
  
  //codigo importado do exemplo do professor em ordem a obter movimento + suave
  /*  void show() {
    if (die) {
      posY += 3*speed;   
    } else {
      if (left) posX -= speed;  // "if(left == true)" igual a "if(left)"
      else if (right) posX += speed;
      else if (up) posY -= speed;
      else if (down) posY += speed;
    }
    image(img, posX, posY);
  }
  */

}
class PlayerShipMenu{

//propriedades
float posX, posY;
boolean state;
Button ship1, ship2, ship3;
Background background;

    //construtor 
    PlayerShipMenu(float x, float y) {
        //background = new Background("assets/images/background.png", 0, 0);
        posX = x;
        posY = y;
        state = false;
        ship1 = new Button("assets/images/first_ship_cs.png", width/2 - 500, height/2 - 100); //image to be changed in the near future
        ship2 = new Button("assets/images/first_ship_secondcs.png", width/2 + 100, height/2 - 100);    //método usado para desenhar os botões
        ship3 = new Button("assets/images/first_ship_thirdcs.png", width/2 + 300, height/2 - 100);
    } 

     public void drawme() {
        //background.drawme();
        if (m.state && state){
            background.drawme();
            ship1.drawme();
            ship2.drawme();
            ship3.drawme();
            shipColor();
        }
    }

    //adicionar aqui metodo para escolher a nave e a bala do player
    //desbloqueaveis com highscore 
     public void shipColor() {
        //logica para escolha na nave + return da string correta para definir
        if(state && m.state){
            if(ship1.press()) ship1.button = loadImage("assets/images/first_ship_cs_pressed.png");
            if(ship2.press()) ship2.button = loadImage("assets/images/first_ship_secondcs_pressed.png");
            if(ship3.press()) ship3.button = loadImage("assets/images/first_ship_thirdcs_pressed.png"); 
        }
    }
}


  public void settings() { fullScreen(P2D);
smooth(8); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "CloudShooter" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
